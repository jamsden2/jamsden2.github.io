<html>
 <head>
    <style type="text/css">
     html, body { height: 100%; margin: 0; padding: 0; }
     #map { height: 100%; }
	 #messageWindow {
		background-color: white;
        border: 1px solid black;
        bottom: 50px;
        padding: 10px;
        position: absolute;
        left: 100px;
		right: 100px;
		font-size: 24pt;
		font-family: arial;
		text-align: center
	 }
   </style>
 </head>
 <body>
	<div id="map"></div>
	<div id="messageWindow">Loading...</div>
	<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBB798KWeyYLq2AVUdbFIDndCp4eiPAk7I&v=3&libraries=geometry">
   
   </script>
<script>

//create the user object
	
var user = {
	//the user position may not seem neccesary, but if I want to implement the 
	//option for the user to search for their own location it will probably help
	position: new google.maps.LatLng(43.466966,-80.5341646),
	lastReloadPosition: new google.maps.LatLng(0,0),
	//for getting the initial data, creating the hole in the reload, and setting bounds for the delete
	get innerRing() {
		var ringRadius = google.maps.geometry.spherical.computeDistanceBetween(map.getCenter(), map.getBounds().getNorthEast());
		//var ringRadius = 500;
		var polygonArray = [];
		for (i = 0; i < 360; i = i + 30) {
			polygonArray.push(google.maps.geometry.spherical.computeOffset(map.getCenter(), ringRadius, i).toJSON());
		};
		return polygonArray;
	},
	//for setting bound of the buffer data load	
	ringArray: function(diameter) {
		var ringRadius = google.maps.geometry.spherical.computeDistanceBetween(map.getCenter(), map.getBounds().getNorthEast()) * diameter;
		//var ringRadius = 1000;
		var polygonArray = [];
		for (i = 0; i < 360; i = i + 30) {
			var pointCoords = [];
			pointCoords.push(google.maps.geometry.spherical.computeOffset(map.getCenter(), ringRadius, i).lng());
			pointCoords.push(google.maps.geometry.spherical.computeOffset(map.getCenter(), ringRadius, i).lat());
			polygonArray.push(pointCoords);
		};
		return polygonArray;
	},
	
	geoGeometry: function(type) {
		var geoQueryObject = {
			rings: [],
			spatialReference: {
				wkid: 4326
			}
		};
		if (type == "full") {
			geoQueryObject.rings.push(user.ringArray(3));
		} else if (type == "viewport") {
			geoQueryObject.rings.push(user.ringArray(1));
		} else if (type == "buffer") {
			geoQueryObject.rings.push(user.ringArray(1));
			geoQueryObject.rings.push(user.ringArray(3));
		};
		return geoQueryObject;
		},
	serviceRequests: 0,
	geoLocates: 0,
	
};





var trees = {
	totalTrees: function() {
		var treeCount = 0;
		map.data.forEach(function(feature) {
			treeCount++;
			});
		return treeCount;
	},
	cleanupTrees: function() {
		map.data.forEach(function(feature) {
			if (google.maps.geometry.spherical.computeDistanceBetween(map.getCenter(), feature.getGeometry().get()) > google.maps.geometry.spherical.computeDistanceBetween(map.getCenter(), map.getBounds().getNorthEast()) * 3) {
			map.data.remove(feature);
			
			};
			
			});
	
	},
	clearAllTrees: function() {
		map.data.forEach(function(feature) {
			map.data.remove(feature);
		});
	
	},
	zoomWas: 0,
	zoomIs: 0
};	

var features = {
	//array of local geojson tree inventory services, split so that I can easily insert the polygon array
	availableServices: [
	["https://services.arcgis.com/ZpeBVw5o1kjit7LT/arcgis/rest/services/StreetTrees/FeatureServer/0/query?where=1%3D1&objectIds=&time=&geometry=", "&geometryType=esriGeometryPolygon&inSR=&spatialRel=esriSpatialRelContains&resultType=none&distance=0.0&units=esriSRUnit_Meter&returnGeodetic=false&outFields=*&returnGeometry=true&multipatchOption=xyFootprint&maxAllowableOffset=&geometryPrecision=&outSR=&returnIdsOnly=false&returnCountOnly=false&returnExtentOnly=false&returnDistinctValues=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&resultOffset=&resultRecordCount=&returnZ=false&returnM=false&quantizationParameters=&sqlFormat=none&f=pgeojson&token="],
	["https://services1.arcgis.com/qAo1OsXi67t7XgmS/arcgis/rest/services/Tree_Inventory/FeatureServer/0/query?where=1%3D1&objectIds=&time=&geometry=", "&geometryType=esriGeometryPolygon&inSR=4326&spatialRel=esriSpatialRelContains&resultType=none&distance=0.0&units=esriSRUnit_Meter&returnGeodetic=false&outFields=*&returnGeometry=true&multipatchOption=xyFootprint&maxAllowableOffset=&geometryPrecision=&outSR=4326&returnIdsOnly=false&returnCountOnly=false&returnExtentOnly=false&returnDistinctValues=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&resultOffset=&resultRecordCount=&returnZ=false&returnM=false&quantizationParameters=&sqlFormat=none&f=pgeojson&token="],
	["https://maps.cambridge.ca/arcgispub/rest/services/OpenData/MapServer/7/query?where=1%3D1&text=&objectIds=&time=&geometry=", "&geometryType=esriGeometryPolygon&inSR=&spatialRel=esriSpatialRelContains&relationParam=&outFields=*&returnGeometry=true&returnTrueCurves=false&maxAllowableOffset=&geometryPrecision=&outSR=&returnIdsOnly=false&returnCountOnly=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&returnZ=false&returnM=false&gdbVersion=&returnDistinctValues=false&resultOffset=&resultRecordCount=&f=geojson"]],
	getData: function(type) {
		for (var i = 0; i < this.availableServices.length; i++) {
		var requestURL = this.availableServices[i][0] + encodeURIComponent(JSON.stringify(user.geoGeometry(type))) + this.availableServices[i][1]
		map.data.loadGeoJson(requestURL);
		}
	}




}


		

	
var geoLocator = navigator.geolocation.watchPosition(function(position) {
	user.position = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
	map.panTo(user.position);
	map.setZoom(21);
	user.geoLocates++;
	console.log("geoLocates: " + user.geoLocates);
	console.log("serviceRequests: " + user.serviceRequests);
	locationMarker.setCenter(user.position);
	
});
	
var map = new google.maps.Map(document.getElementById('map'),{
	center: user.position,
	zoom: 12
});	







var locationMarker = new google.maps.Circle({
		strokeColor: '#FF0000',
		strokeOpacity: 0.8,
		strokeWeight: 2,
		fillColor: '#FF0000',
		fillOpacity: 0.35,
		map: map,
		center: user.position,
		radius: 5
	});
	

map.data.setStyle({
		icon: {
				path: google.maps.SymbolPath.CIRCLE,
				scale: 7,
				strokeColor: 'green',
				strokeOpacity: 0.8,
				strokeWeight: 2,
				fillColor: 'green',
				fillOpacity: 0.2,
		}
	});		



//listeners
//map is idle
map.addListener('idle', function() {

	
	//check if user is zoomed too far out
	if (map.getZoom() < 18) {
		trees.clearAllTrees();
		document.getElementById('messageWindow').textContent = "You've zoomed out too far. Zoom in so I can get some data for you.";
	} else {
		//update user position property - this is used in some areas that we don't want to use getCenter
		//this is dead wrong and I based stuff off of it...
		//user.position = map.getCenter();
		//remove trees outside of buffer. we don't want to slow down the user's experience
		trees.cleanupTrees();
		var distanceLastReload = google.maps.geometry.spherical.computeDistanceBetween(map.getCenter(), user.lastReloadPosition);
		console.log(distanceLastReload);
		if (distanceLastReload < google.maps.geometry.spherical.computeDistanceBetween(map.getCenter(), map.getBounds().getNorthEast()) * 1.5) {
			//console.log("get new data");
			document.getElementById('messageWindow').textContent = "Loading trees...";
			features.getData("buffer");
			
			user.serviceRequests++;
			console.log("serviceRequests: " + user.serviceRequests);
			document.getElementById('messageWindow').textContent = "Trees Loaded.";
		
			user.lastReloadPosition = map.getCenter();
		
		} else {
			features.getData("full");
			user.serviceRequests++;
			console.log("serviceRequests: " + user.serviceRequests);
			user.lastReloadPosition = map.getCenter();
			document.getElementById('messageWindow').textContent = "Trees Loaded.";
		};
	console.log("I'm idle!");
	console.log(trees.totalTrees());
	var treeDataArray = [];
	
	map.data.forEach(function(feature){
		var treeObject = {
		name: "tree name",
		coordinates: {},
		distanceToUser: 9999999
		};
		var treeCommonNameOptions = ["COM_NAME", "COMMON_NAME", "SPECIES_NAME"];
		var treeNormalizedName = "Unknown";
		for (var i = 0; i < treeCommonNameOptions.length; i++){
			var treeName = feature.getProperty(treeCommonNameOptions[i]); 
			if (treeName) {
				//console.log("NAME: ", treeName);
				treeObject.name = {treeName};
			};
		};	
		treeObject.coordinates = feature.getGeometry().get();
		treeObject.distanceToUser = google.maps.geometry.spherical.computeDistanceBetween(user.position, treeObject.coordinates);
		treeDataArray.push(treeObject);
		//console.log(treeObject);
		//console.log("ALL DATA");
		//feature.forEachProperty(function(value, property) {
		//	console.log(property, ":", value);
		//});
	});
	
	treeDataArray.sort(function(a,b) {
			return parseFloat(a.distanceToUser) - parseFloat(b.distanceToUser);
		});
	//console.log(treeDataArray);
	document.getElementById('messageWindow').textContent = "The closest tree to you is a " + treeDataArray[0]["name"]["treeName"] + ". It's " + Math.round(treeDataArray[0]["distanceToUser"]) + "m away. There is also a " + treeDataArray[1]["name"]["treeName"] + " " + Math.round(treeDataArray[1]["distanceToUser"]) + "m away.";
	
	};	
});



map.addListener('zoom_changed', function() {
	user.zoomWas = user.zoomIs;
	user.zoomIs = map.getZoom();
	if (user.zoomWas < 18 & user.zoomIs >= 18) {
		console.log("I should get more data.");
		features.getData("viewport");
		user.serviceRequests++;	
		document.getElementById('messageWindow').textContent = "Trees Loaded.";
		
	};

	
	
	
map.addListener('drag', function() {
	document.getElementById('messageWindow').textContent = "Panning...";
	locationMarker.setCenter(map.getCenter());
	user.position = map.getCenter();

});
	
});




	
  

  </script>
  
   
   
 </body>
</html>